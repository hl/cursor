---
description: 
globs: ["**/*.exs"]
alwaysApply: false
---
# Elixir ExUnit Test Conventions

## Description
This rule outlines general conventions and best practices for writing ExUnit tests in Elixir projects. Adherence to these conventions promotes consistency, maintainability, and correctness of tests across different applications.

**Note:** Throughout this document, placeholders like `MyApp`, `my_app`, and `:my_app_name` are used. These should be replaced with the specific names relevant to the application you are working on (e.g., the application name defined in your `mix.exs` file via the `:app` key).

## Rule
When writing or modifying Elixir ExUnit tests (`.exs` files):

### General Test Structure & Setup
1.  **DataCase Usage**: Always begin tests with `use MyApp.DataCase, async: true` (or the equivalent main DataCase module for your application).
2.  **File Naming and Location**:
    *   Test file paths MUST mirror the source file paths, typically replacing `lib/` with `test/` and appending `_test.exs` to the module name (e.g., `_test.exs` for `.ex` files).
    *   Example: `lib/my_app/some_module.ex` would have its test file in `test/my_app/some_module_test.exs`.
    *   Example: `lib/my_app_web/live/feature/item_live/index.ex` would have the test `test/my_app_web/live/feature/item_live/index_test.exs`.

### Data Generation & Factories
3.  **Factory Usage**:
    *   ALWAYS use factories (e.g., `insert(:my_factory, attr: value)`) for creating test data.
    *   NEVER use `Repo.insert` directly. `MyApp.Repo` (or the application's primary Ecto Repo module) should NEVER be mocked for data generation.
    *   If the required factory is unknown, you MUST ask the user for clarification.
4.  **Factory Definitions**:
    *   New factories SHOULD be created in new files within `test/support/factories/`.
    *   Do NOT add factory definitions directly to the main `test/support/factory.ex` file if it's meant only for aggregation or setup. Instead, reference the new factory modules from it if necessary.
    *   Follow the established pattern for factories within the project. If unsure, look for existing examples or use a general structure like:
        ```elixir
        # Example Factory Structure:
        # defmodule MyApp.Factories.MySchemaFactory do
        #   alias MyApp.MyContext.MySchema
        #
        #   defmacro __using__(_opts) do
        #     quote do
        #       def my_schema_factory(attrs) do
        #         # Example of handling a common association like a tenant:
        #         # tenant = Map.get_lazy(attrs, :tenant, fn -> build(:tenant_factory_name) end)
        #
        #         %MyApp.MyContext.MySchema{
        #           # tenant: tenant, # if applicable
        #           # ... other fields ...
        #         }
        #         |> merge_attributes(attrs)
        #         |> evaluate_lazy_attributes()
        #       end
        #     end
        #   end
        # end
        ```
5.  **Factory Attributes**:
    *   When associating models (e.g., a `tenant`), pass the full model struct (e.g., `tenant: tenant_struct`), NOT the `_id` (e.g., `tenant_id: "uuid"`) unless the factory is specifically designed for `_id` input.
    *   NEVER generate `id` or `_id` fields with random UUIDs/integers if they are auto-generated by the database/Ecto upon insertion.
6.  **Tenant/Context Specifics (If Applicable)**:
    *   If the application uses a multi-tenant pattern (e.g., with `tenant_id`), ensure all relevant data and queries are correctly scoped.
    *   Be aware of primary key conventions (e.g., some tables might use `tenant_id` as PK, while others use `id`).

### Tenant Isolation (If Applicable)
7.  **Scoped Data Checks**: If the application has data isolation (e.g., by `tenant_id`), ALWAYS write tests to verify this. Ensure that data is correctly scoped and users/contexts cannot access data from other tenants/scopes.

### Mocking (Using Mox or Similar)
8.  **When to Mock**: Mocking should generally be a last resort. Prefer testing with real implementations where feasible. If mocking is necessary (e.g., for external services, or complex stateful components not under test), use the project's designated mocking library (e.g., Mox). Mocking is permitted ONLY when explicitly instructed or clearly appropriate for isolating the unit under test.
9.  **Data Generation**: NEVER use mocks for generating test data for your application's database entities. ALWAYS use factories. Specifically, the application's primary Ecto Repo (`MyApp.Repo`) MUST NOT be mocked for data setup.
10. **General Procedure for Using Mocks (e.g., Mox)**:
    a.  **Define Behaviour**: Create an Elixir behaviour for the module/functionality you intend to mock.
    b.  **Implement Behaviour**: Ensure the actual module implements this behaviour.
    c.  **Define Mocks**: Add mock definitions in the appropriate test setup location (e.g., `test/test_helper.exs` for global mocks, or `setup_all` blocks for test-specific mocks).
    d.  **Utilize Mocks**: Use the defined mocks within your test cases.
    e.  **Verify Mocks**: If using Mox, call `setup :verify_on_exit!` at the top of any test file that uses its mocks.
11. **Implementation Selection for Mocks**:
    *   To choose between the real implementation and a mock at runtime (often for testing), use `Application.get_env/3`. Example:
        ```elixir
        def feature_implementation do
          Application.get_env(:my_app_name, :feature_client, DefaultImplementationModule)
        end
        ```
    *   NEVER use module attributes (e.g., `@some_module`) or `Application.compile_env/3` for selecting implementations that need to be dynamically switched for testing purposes.
12. **Setting Mock Implementation in Tests**:
    *   In your test setup (or individual tests), switch to the mock implementation using `Application.put_env/3`. Example:
        ```elixir
        Application.put_env(:my_app_name, :feature_client, MockImplementationModule)
        ```

### LiveView Tests (If Applicable)
13. **Imports**: LiveView tests MUST include `import Phoenix.LiveViewTest` if Phoenix LiveView is used.
14. **Setup Block**:
    *   Utilize a `setup` block to create and log in users, and to enable any necessary feature flags relevant to the LiveView under test.
    *   Login helper functions are often defined in a project-specific `ConnCase` (e.g., `MyAppWeb.ConnCase` in `test/support/conn_case.ex`). Refer to this file for available helpers.
    *   The user is typically created by the login helper; ensure this is done before creating other data that depends on the user.
    *   Example setup structure:
        ```elixir
        # setup %{conn: conn} do
        #   # Example: if using tenants
        #   # tenant = insert(:tenant_factory_name) 
        #   # context = %{user: user} = register_and_log_in_user_function(%{conn: conn}, tenant)
        #   # ... other setup like feature flags, etc. ...
        #   # Map.merge(context, %{tenant: tenant, # ... other assigns ...})
        # end
        ```
15. **Cross-Context Access in LiveViews**: If a LiveView URL includes identifiers that scope data (e.g., a tenant ID), ALWAYS write tests to check that users cannot access data from other contexts/scopes they shouldn't have access to.

### Test Execution
16. **Running Tests**:
    *   Before executing `mix test` or any related Mix commands, ensure you are in the root directory of the Elixir application (where `mix.exs` is located).
    *   After you create or update a test, you MUST then run that specific test or the relevant test file to verify its correctness.

### Clarifications
17. **Unclear Data Setup**: If it is not clear how to set up test data for a specific scenario, you MUST ask the user to provide an example or point to a file with a similar setup within the current project.

## Scope
This rule applies to all files matching the glob pattern: `*.exs`.
